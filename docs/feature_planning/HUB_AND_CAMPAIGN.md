

---

# HUB & CAMPAIGN — SCHEMA + MUTATION + OFFER GENERATOR

*(Canonical, Implementation-Grade)*

This document defines **exact schemas**, **mutation rules**, and a **campaign offer generator** consistent with all prior decisions.

No lore. No vibes. This is executable design.

---

## 1. Core Concepts (Locked)

### Structural Truths

* **HubState** is persistent, non-simulated, authoritative.
* **CampaignScenario** is a *proposal* generated by the Hub.
* **CampaignState** is instantiated from a scenario.
* **CampaignOutcome** is the *only* thing allowed to mutate HubState.
* Difficulty is **derived**, not selected.
* Recon refines **uncertainty**, not rewards.

---

## 2. Difficulty Model (Derived, Descriptive)

Difficulty is **not a fixed tier**.
It is **calculated**, then rendered as descriptive text.

### Difficulty Inputs (Partial List)

```python
difficulty_inputs = {
    "threat_density": float,        # 0.0 – 1.0
    "threat_variance": float,
    "victory_complexity": int,      # number of conditions + modifiers
    "resource_scarcity": float,
    "signal_noise": float,
    "environmental_hostility": float,
    "unknown_factor_weight": float  # how much is hidden pre-recon
}
```

### Difficulty Calculation

```python
difficulty_score = weighted_sum(difficulty_inputs)
```

### Difficulty Descriptor (Player-Facing)

```python
DIFFICULTY_DESCRIPTORS = [
    (0.0, 0.8, "LOW CONFIDENCE OPERATION"),
    (0.8, 1.6, "UNSTABLE CONDITIONS"),
    (1.6, 2.4, "HIGH RISK ENGAGEMENT"),
    (2.4, 3.2, "SEVERE OPERATIONAL COMPLEXITY"),
    (3.2, 999, "EXTINCTION-LEVEL UNKNOWN")
]
```

The **descriptor**, not the score, is shown to the player.

---

## 3. CampaignScenario Schema (Exact)

```python
CampaignScenario:
    id: UUID
    seed: int

    region:
        region_id: str              # abstract, semantic-adjacent IDs
        similarity_hint: Optional[str]

    difficulty:
        score: float
        descriptor: str

    setting:
        biome: str
        environmental_tags: list[str]

    threat_profile:
        dominant_threat: str
        secondary_threats: list[str]
        signal_confidence: float     # 0–1

    victory_conditions:
        primary:
            type: str                # RECOVERY | STABILIZATION | CONTAINMENT | NEUTRALIZATION
            target_descriptor: str
            completion_threshold: float
        modifiers: list[VictoryModifier]

    optional_subvictories:
        discovered: bool             # initially False
        possible_types: list[str]    # revealed via recon or hub upgrades

    resource_profile:
        availability_index: float
        artifact_density_estimate: float

    uncertainty:
        unknown_fields: list[str]    # what recon can refine
        noise_level: float

    reward_profile:
        archetype: str               # BIOLOGICAL | INDUSTRIAL | ARCHIVAL | PRECURSOR
        scaling_rules: RewardScalingRules
```

---

## 4. Victory Conditions (Structured, Expandable)

```python
VictoryModifier:
    type: str                        # TIME_DRIFT | SIGNAL_DECAY | HOSTILE_ADAPTATION
    severity: float
```

Key rule:

> **Primary victory condition enables campaign resolution but does not force it.**

Players may remain to pursue **secondary victories**.

---

## 5. Reward Model (Interpretive, Step-Based)

### Reward Archetypes (Hub-Facing)

```python
RewardArchetype:
    unlocks:
        possible: list[str]
    standardized_unlocks:
        exact: list[str]
    archive_entries:
        categories: list[str]
```

Examples of **standardized unlocks**:

* `RECON_SIGNAL_FILTER_V1`
* `SECONDARY_OBJECTIVE_DETECTION`
* `ARCHIVE_LOSS_TOLERANCE +1`

---

## 6. CampaignOutcome Schema (Only Hub Mutation Input)

```python
CampaignOutcome:
    scenario_id: UUID
    result: COMPLETE | PARTIAL | FAILURE | ABANDONED

    primary_victory_completion: float  # 0.0 – 1.0

    secondary_victories:
        achieved: list[str]
        failed: list[str]

    losses:
        archive_loss: int
        structural_loss: bool

    extracted_artifacts:
        type_tags: list[str]
        integrity_scores: list[float]

    derived_insights:
        inferred_tech_lineages: list[str]
        historical_estimates: dict

    seed: int
```

---

## 7. HubState Schema (Persistent)

```python
HubState:
    seed: int

    capability_flags:
        recon_depth: int
        subvictory_detection: bool
        archive_loss_tolerance: int

    unlocked_scenario_archetypes: set[str]
    unlocked_victory_modifiers: set[str]

    knowledge_archive:
        entries: list[ArchiveEntry]

    campaign_history:
        campaigns: list[CampaignRecord]
```

```python
CampaignRecord:
    scenario_id: UUID
    region_id: str
    outcome: str
    difficulty_descriptor: str
    timestamp: int
    notes: dict
```

---

## 8. Hub Mutation Rules (Strict)

### Single Entry Point

```python
def apply_campaign_outcome(hub: HubState, outcome: CampaignOutcome) -> HubState:
    ...
```

### Mutation Rules

1. **Primary Victory**

   * Applies base reward archetype.
   * Unlocks standardized unlocks if completion ≥ threshold.

2. **Partial Victory**

   * Applies reduced unlock probability.
   * Archive entries are degraded or incomplete.

3. **Secondary Victories**

   * Reward multiplier:

     ```
     secondary_reward_value = base * secondary_weight * primary_completion
     ```

4. **Failure**

   * No unlocks.
   * Campaign history updated.
   * Possible archive loss.

5. **Abandonment**

   * Archive loss scaled by depth of incursion.
   * No unlocks.

No other system may mutate HubState.

---

## 9. Recon System (Hub-Side Only)

```python
def apply_recon(hub: HubState, scenario: CampaignScenario) -> CampaignScenario:
    # Removes some unknown_fields
    # Reduces noise_level
    # Reveals possible_subvictories if capability allows
```

Recon **never**:

* reveals exact rewards
* changes difficulty score
* alters campaign seed

---

## 10. Campaign Offer Generator (Exact Example)

```python
def generate_campaign_offer(hub: HubState, seed: int) -> CampaignScenario:
    rng = Random(seed)

    inputs = generate_difficulty_inputs(rng, hub)
    score = calculate_difficulty(inputs)
    descriptor = map_descriptor(score)

    scenario = CampaignScenario(
        id=uuid4(),
        seed=seed,
        region=generate_region(rng),
        difficulty={ "score": score, "descriptor": descriptor },
        setting=generate_setting(rng),
        threat_profile=generate_threats(rng, hub),
        victory_conditions=generate_victory_conditions(rng, score),
        optional_subvictories=generate_subvictory_potential(rng, hub),
        resource_profile=generate_resources(rng),
        uncertainty=generate_uncertainty(rng),
        reward_profile=select_reward_archetype(rng)
    )

    return scenario
```

---

## 11. Example Campaign Offer (Player-Facing)

```
REGION: RX-113A
OPERATIONAL COMPLEXITY: HIGH RISK ENGAGEMENT

PRIMARY OBJECTIVE:
– Recover biological artifact of unknown origin

MODIFIERS:
– Signal degradation detected
– Hostile genetic adaptation likely

ADDITIONAL SIGNALS:
– Secondary anomalies possible (unconfirmed)

RESOURCE CONDITIONS:
– Scarce
– Artifact density above baseline

NOTE:
Recon may refine threat classification.
```

---

## 12. What Codex Can Implement Immediately

* All schemas above as dataclasses
* Difficulty calculation + descriptor mapping
* Campaign offer generator
* Hub mutation function
* Recon as metadata transformer
* Example deterministic tests (seeded)

---

## 13. Final Lock

This model:

* resolves the **contracts vs assertions** conflict
* preserves **agency + structure**
* supports **procedural difficulty**
* enables **knowledge-driven progression**
* fits your **existing engine without rewrite**



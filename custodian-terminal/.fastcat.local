=== boot.js ===
const terminal = document.getElementById("terminal");

const hum = document.getElementById("hum");
const relay = document.getElementById("relay");
const beep = document.getElementById("beep");
const timingRelay = document.getElementById("timingRelay");
const fourBeep = document.getElementById("fourBeep");
const hddSpin = document.getElementById("hddSpin");
const alertSound = document.getElementById("alert");

const terminalController = window.CustodianTerminal;

/* =========================
   Audio: policy-safe init
   ========================= */

let audioReady = false;

function tryStartHum() {
  hum.volume = 0.15;
  hum.play().then(() => {
    audioReady = true;
  }).catch(() => {});
}

tryStartHum();

function unlockAudioOnce() {
  if (audioReady) return;
  tryStartHum();
  [relay, timingRelay, fourBeep, hddSpin, beep, alertSound].forEach((el) => {
    try {
      el.volume = 0.0;
      el.currentTime = 0;
      el.play().then(() => el.pause()).catch(() => {});
    } catch {}
  });
  audioReady = true;
  window.removeEventListener("pointerdown", unlockAudioOnce);
  window.removeEventListener("keydown", unlockAudioOnce);
}
window.addEventListener("pointerdown", unlockAudioOnce, { once: true });
window.addEventListener("keydown", unlockAudioOnce, { once: true });

/* =========================
   Audio: one-shot helper
   ========================= */

function playOneShot(el, { volume = 0.2, rateJitter = 0.03, restart = true } = {}) {
  if (!el) return;
  const a = el.cloneNode(true);
  a.volume = volume;
  a.playbackRate = 1 + (Math.random() * 2 - 1) * rateJitter;
  if (restart) {
    a.currentTime = 0;
  }
  a.play().catch(() => {});
}

let alertPulseCooldown = 0;

function playSingleShot(el, { volume = 0.2, rate = 1.0 } = {}) {
  if (!el) return;
  el.volume = volume;
  try {
    el.currentTime = 0;
    el.playbackRate = rate;
    el.play().catch(() => {});
  } catch {}
}

function fadeOut(el, startMs, endMs, startVolume) {
  const start = performance.now() + startMs;
  const end = performance.now() + endMs;
  const initial = typeof startVolume === "number" ? startVolume : el.volume || 0.2;

  function tick(now) {
    if (now < start) {
      requestAnimationFrame(tick);
      return;
    }
    const t = Math.min(1, (now - start) / (end - start));
    el.volume = Math.max(0, initial * (1 - t));
    if (t < 1) {
      requestAnimationFrame(tick);
    }
  }

  requestAnimationFrame(tick);
}

function playRelaySequence() {
  if (timingRelay) {
    playSingleShot(timingRelay, { volume: 0.18 });
    fadeOut(timingRelay, 2000, 5000, 0.18);
  }
  if (fourBeep) {
    setTimeout(() => {
      playSingleShot(fourBeep, { volume: 0.18 });
    }, 1000);
  }
}

function playHddSpinOnce() {
  if (!hddSpin) return;
  hddSpin.loop = false;
  hddSpin.volume = 0.12;
  hddSpin.currentTime = 0;
  hddSpin.play().catch(() => {});
  fadeOut(hddSpin, 8000, 14000, 0.12);
}

function playAlertPulse() {
  const now = performance.now();
  if (now < alertPulseCooldown) return;
  const pulseRate = 1.0;
  const timings = [0, 1500, 3000].map((t) => t / pulseRate);
  alertPulseCooldown = now + 3600 / pulseRate;
  const sequence = [
    { el: alertSound, delay: timings[0], volume: 0.2, rate: 1.0 },
    { el: alertSound, delay: timings[1], volume: 0.18, rate: 1.0 },
    { el: alertSound, delay: timings[2], volume: 0.18, rate: 1.0 },
  ];
  sequence.forEach(({ el, delay, volume, rate }) => {
    setTimeout(() => {
      playSingleShot(el || alertSound, { volume, rate });
    }, delay);
  });
}

function clearTerminalAnimated(durationMs = 5000) {
  return new Promise((resolve) => {
    const text = terminal.innerText || terminal.textContent || "";
    const total = text.length;
    if (!total) {
      resolve();
      return;
    }

    const start = performance.now();
    let lastRemaining = total;
    let lastClickRemaining = total;
    const clickStride = 12;

    function tick(now) {
      const elapsed = now - start;
      const progress = Math.min(1, elapsed / durationMs);
      const remaining = Math.ceil(total * (1 - progress));
      if (remaining !== lastRemaining) {
        terminal.textContent = text.slice(0, remaining);
        terminal.scrollTop = terminal.scrollHeight;
        if (lastClickRemaining - remaining >= clickStride || remaining <= 0) {
          lastClickRemaining = remaining;
        }
        lastRemaining = remaining;
      }

      if (progress < 1) {
        requestAnimationFrame(tick);
      } else {
        terminal.textContent = "";
        resolve();
      }
    }

    requestAnimationFrame(tick);
  });
}

function isWarningLine(text) {
  const t = text.toUpperCase();
  return (
    t.includes("WARNING") ||
    t.includes("ALERT") ||
    t.includes("DEGRADED") ||
    t.includes("OFFLINE") ||
    t.includes("UNSTABLE")
  );
}

function isSystemNoiseLine(text) {
  const t = text.toUpperCase();
  return t.startsWith("[") || t.startsWith(">") || t.includes("STATUS");
}

function isDirectiveLine(text) {
  const t = text.toUpperCase();
  return t.includes("DIRECTIVE") || t.includes("MANDATE") || t.includes("AUTHORITY");
}

function linePauseMs(text) {
  if (!text) {
    return 320 + Math.random() * 420;
  }
  if (isWarningLine(text)) {
    return 520 + Math.random() * 520;
  }
  if (isDirectiveLine(text)) {
    return 380 + Math.random() * 420;
  }
  if (isSystemNoiseLine(text)) {
    return 240 + Math.random() * 320;
  }
  return 200 + Math.random() * 280;
}

/* =========================
   Boot text
   ========================= */

const bootLines = [
  "[ SYSTEM POWER: UNSTABLE ]",
  "[ AUXILIARY POWER ROUTED ]",
  "",
  "CUSTODIAN NODE - ONLINE",
  "STATUS: DEGRADED",
  "",
  "> Running integrity check...",
  "> Memory blocks: 12% intact",
  "> Long-range comms: OFFLINE",
  "> Archive uplink: INACCESSIBLE",
  "> Automated defense grid: PARTIAL",
  "",
  "DIRECTIVE FOUND",
  "RETENTION MANDATE - ACTIVE",
  "",
  "WARNING:",
  "Issuing authority presumed defunct.",
  "",
  "Residual Authority accepted.",
  "",
  "Initializing Custodian interface...",
];

/**
 * Pause for a set duration.
 * @param {number} ms
 * @returns {Promise<void>}
 */
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Type out a single boot line to the terminal, with realistic audio cadence.
 * @param {string} text
 * @returns {Promise<void>}
 */
function typeLine(text) {
  return new Promise((resolve) => {
    let i = 0;

    if (text && isWarningLine(text)) {
      playAlertPulse();
      hum.volume = 0.18;
      setTimeout(() => (hum.volume = 0.15), 500);
    } else if (text && isSystemNoiseLine(text) && Math.random() < 0.35) {
      playOneShot(beep, { volume: 0.08, rateJitter: 0.02 });
    }

    const baseDelay = 22 + Math.random() * 32;

    const interval = setInterval(() => {
      const ch = text[i] || "";
      terminal.textContent += ch;
      i += 1;

      if (i >= text.length) {
        clearInterval(interval);

        if (text && Math.random() < 0.35) {
          playOneShot(relay, { volume: 0.06, rateJitter: 0.03 });
        }

        terminal.textContent += "\n";
        terminal.scrollTop = terminal.scrollHeight;
        resolve();
      }
    }, baseDelay + Math.random() * 22);
  });
}

function appendStreamedLine(text) {
  if (text && isWarningLine(text)) {
    playAlertPulse();
    hum.volume = 0.18;
    setTimeout(() => (hum.volume = 0.15), 500);
  } else if (text && isSystemNoiseLine(text) && Math.random() < 0.35) {
    playOneShot(beep, { volume: 0.08, rateJitter: 0.02 });
  }
  terminalController.appendLine(text);
  terminal.classList.add("flicker");
  setTimeout(() => terminal.classList.remove("flicker"), 120);
}

/**
 * Stream boot lines from the server if available.
 * @returns {Promise<boolean>}
 */
function streamBootFromServer() {
  return new Promise((resolve) => {
    let hasData = false;
    let done = false;

    const source = new EventSource("/stream/boot");

    source.onmessage = (event) => {
      hasData = true;
      appendStreamedLine(event.data);
    };

    source.addEventListener("done", () => {
      done = true;
      source.close();
      resolve(true);
    });

    source.onerror = () => {
      if (!hasData && !done) {
        source.close();
        resolve(false);
      }
    };

    setTimeout(() => {
      if (!hasData && !done) {
        source.close();
        resolve(false);
      }
    }, 800);
  });
}

/**
 * Boot sequence before handing off to command mode.
 * @returns {Promise<void>}
 */
async function runBoot() {
  terminalController.setInputEnabled(false);

  playOneShot(relay, { volume: 0.2, rateJitter: 0.04 });
  playRelaySequence();
  await sleep(420);

  const streamed = await streamBootFromServer();
  if (!streamed) {
    const pauseSteps = [1000, 2000, 3000];
    const pauseStart = Math.max(0, bootLines.length - pauseSteps.length);
    for (let i = 0; i < bootLines.length; i += 1) {
      const line = bootLines[i];
      await typeLine(line);
      terminal.classList.add("flicker");
      setTimeout(() => terminal.classList.remove("flicker"), 120);
      if (i >= pauseStart) {
        await sleep(pauseSteps[i - pauseStart]);
      } else {
        await sleep(linePauseMs(line));
      }
    }
  }

  await sleep(900);
  if (timingRelay) {
    timingRelay.loop = true;
    timingRelay.volume = 0.18;
    timingRelay.currentTime = 0;
    timingRelay.play().catch(() => {});
    fadeOut(timingRelay, 4000, 7000, 0.18);
    setTimeout(() => {
      timingRelay.pause();
      timingRelay.currentTime = 0;
    }, 7000);
  }
  
  await clearTerminalAnimated(5000);
  terminalController.clearBuffer();

  await sleep(240);

  // Render initial map snapshot BEFORE command mode
  try {
    const snapshot = await fetch("/snapshot").then((r) => r.json());
    if (window.CustodianSectorMap) {
      window.CustodianSectorMap.renderSectorMap(snapshot);
    }
    terminalController.appendLine("[MAP UPDATED]");
  } catch {
    terminalController.appendLine("[MAP STATUS UNKNOWN]");
  }

  // Enter command mode
  terminalController.startCommandMode();
  playHddSpinOnce();

}

runBoot();



=== index.html ===

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CUSTODIAN</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

  <!-- AUDIO -->
  <audio id="hum" src="sounds/hum.mp3" loop></audio>
  <audio id="relay" src="sounds/relay.mp3"></audio>
  <audio id="beep" src="sounds/beep.mp3"></audio>
  <audio id="timingRelay" src="sounds/timing-relay.mp3"></audio>
  <audio id="fourBeep" src="sounds/4-beep.mp3"></audio>
  <audio id="hddSpin" src="sounds/hdd-spin-normalized.mp3"></audio>
  <audio id="alert" src="sounds/alert.mp3"></audio>

  <div id="app-shell">
    <!-- TERMINAL -->
    <div id="terminal-container">
      <pre id="terminal"></pre>
      <div id="new-output-indicator">NEW OUTPUT</div>

      <form id="terminal-input-form" autocomplete="off">
        <span id="terminal-prompt">&gt;</span>
        <input id="terminal-input" type="text" spellcheck="false" disabled />
      </form>

      <div id="status-bar">
        <span>AUTHORITY: RESIDUAL</span>
        <span>MANDATE: ACTIVE</span>
      </div>
    </div>

    <!-- SECTOR MAP + SYSTEM PANEL -->
    <div id="side-panel">
      <div id="sector-map"></div>
      <div id="system-panel"></div>
    </div>
  </div>

  <script src="sector_layout.js"></script>
  <script src="sector-map.js"></script>
  <script src="terminal.js"></script>
  <script src="boot.js"></script>
</body>
</html>



=== sector_layout.js ===
(() => {
  const SECTOR_LAYOUT = [
    { id: "CM", name: "COMMS", x: 1, y: 0, role: "info" },
    { id: "DF", name: "DEFENSE GRID", x: 0, y: 1, role: "mitigation" },
    { id: "CC", name: "COMMAND", x: 1, y: 1, role: "authority" },
    { id: "PW", name: "POWER", x: 2, y: 1, role: "amplifier" },
    { id: "AR", name: "ARCHIVE", x: 1, y: 2, role: "goal" },
    { id: "ST", name: "STORAGE", x: 1, y: 3, role: "buffer" },
    { id: "HG", name: "HANGAR", x: 0, y: 4, role: "egress" },
    { id: "GS", name: "GATEWAY", x: 1, y: 4, role: "ingress" },
  ];

  window.CustodianSectorLayout = {
    SECTOR_LAYOUT,
  };
})();



=== sector-map.js ===
(() => {
  const MAP_CONTAINER_ID = "sector-map";
  const SYSTEM_PANEL_ID = "system-panel";

  const STATUS_CLASS = {
    STABLE: "stable",
    ALERT: "alert",
    DAMAGED: "damaged",
    COMPROMISED: "compromised",
  };

  const STATUS_SEVERITY = {
    STABLE: 0,
    ALERT: 1,
    DAMAGED: 2,
    COMPROMISED: 3,
  };

  let lastSnapshot = null;
  let lastPanelSnapshot = null;

  function clearNode(node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  }

  function getCommsStatus(snapshot) {
    const comms = snapshot.sectors.find((sector) => sector.id === "CM");
    return comms?.status || "STABLE";
  }

  function formatPanelLine(label, value) {
    const paddedLabel = label.padEnd(10, ".");
    return `${paddedLabel} ${value}`;
  }

  function formatPosture(snapshot, layout) {
    if (snapshot.hardened) {
      return "HARDENED";
    }
    if (snapshot.focused_sector) {
      const entry =
        layout.find((sector) => sector.id === snapshot.focused_sector) || {};
      const name = entry.name || snapshot.focused_sector;
      return `FOCUSED (${name})`;
    }
    return "NONE";
  }

  function applyCommsCollapse(status, commsStatus) {
    if (commsStatus === "DAMAGED" || commsStatus === "COMPROMISED") {
      return status === "DAMAGED" || status === "COMPROMISED"
        ? "CRITICAL"
        : "UNSTABLE";
    }
    return status;
  }

  function pickNoSignalSector(snapshot, layout) {
    const pool =
      layout.length > 0
        ? layout.map((item) => item.id)
        : snapshot.sectors.map((sector) => sector.id);
    const candidates = pool.filter((id) => id && id !== "CC");
    if (!candidates.length) return null;
    return candidates[snapshot.time % candidates.length];
  }

  function renderSystemPanel(snapshot, layout, commsStatus) {
    const container = document.getElementById(SYSTEM_PANEL_ID);
    if (!container) return;

    if (snapshot.failed && lastPanelSnapshot) {
      container.classList.add("panel-failed");
      return;
    }

    clearNode(container);

    const lines = [
      formatPanelLine("TIME", snapshot.time),
      formatPanelLine("THREAT", snapshot.threat),
      formatPanelLine(
        "ASSAULT",
        commsStatus === "COMPROMISED" ? `${snapshot.assault}?` : snapshot.assault
      ),
      formatPanelLine("POSTURE", formatPosture(snapshot, layout)),
      formatPanelLine(
        "ARCHIVE",
        `${snapshot.archive_losses} / ${snapshot.archive_limit}`
      ),
    ];

    lines.forEach((line) => {
      const row = document.createElement("div");
      row.className = "system-panel-line";
      row.textContent = line;
      container.appendChild(row);
    });

    container.classList.toggle("panel-degraded", commsStatus === "DAMAGED");
    container.classList.toggle(
      "panel-compromised",
      commsStatus === "COMPROMISED"
    );
    container.classList.toggle("panel-failed", snapshot.failed);

    lastPanelSnapshot = snapshot;
  }

  function renderSectorMap(snapshot) {
    const container = document.getElementById(MAP_CONTAINER_ID);
    if (!container) return;

    clearNode(container);

    const layout = window.CustodianSectorLayout?.SECTOR_LAYOUT || [];
    const sectorById = new Map(
      snapshot.sectors.map((sector) => [sector.id, sector])
    );
    const commsStatus = getCommsStatus(snapshot);
    const noSignalId =
      commsStatus === "COMPROMISED" ? pickNoSignalSector(snapshot, layout) : null;

    const header = document.createElement("div");
    header.className = "sector-map-header";
    header.textContent = "SECTOR SNAPSHOT";

    const meta = document.createElement("div");
    meta.className = "sector-map-meta";
    const assaultText =
      commsStatus === "COMPROMISED" ? `${snapshot.assault}?` : snapshot.assault;
    meta.textContent = `TIME ${snapshot.time} | THREAT ${snapshot.threat} | ASSAULT ${assaultText}`;

    const grid = document.createElement("div");
    grid.className = "sector-map-grid";

    const renderList = layout.length > 0 ? layout : snapshot.sectors;

    renderList.forEach((layoutItem) => {
      const sector =
        layout.length > 0
          ? sectorById.get(layoutItem.id)
          : layoutItem;

      if (!sector) {
        return;
      }

      const card = document.createElement("div");
      card.className = "sector-card";

      const statusClass = STATUS_CLASS[sector.status] || "stable";
      card.classList.add(statusClass);
      if (layoutItem.role) {
        card.classList.add(`role-${layoutItem.role}`);
      }

      const name = document.createElement("div");
      name.className = "sector-name";
      name.textContent = sector.name || layoutItem.name;

      const status = document.createElement("div");
      status.className = "sector-status";
      let displayStatus = applyCommsCollapse(sector.status, commsStatus);
      if (noSignalId && sector.id === noSignalId) {
        displayStatus = "[NO SIGNAL]";
      }
      status.textContent = displayStatus;

      if (layout.length > 0) {
        card.style.gridColumn = layoutItem.x + 1;
        card.style.gridRow = layoutItem.y + 1;
      }

      const previousStatus = lastSnapshot?.sectors?.find(
        (prev) => prev.id === sector.id
      )?.status;
      const previousSeverity = STATUS_SEVERITY[previousStatus] ?? 0;
      const currentSeverity = STATUS_SEVERITY[sector.status] ?? 0;
      if (currentSeverity > previousSeverity) {
        card.classList.add("recent-hit");
        setTimeout(() => {
          card.classList.remove("recent-hit");
        }, 420);
      }

      card.appendChild(name);
      card.appendChild(status);
      grid.appendChild(card);
    });

    container.appendChild(header);
    container.appendChild(meta);
    container.appendChild(grid);

    container.classList.toggle("map-degraded", commsStatus === "ALERT");
    container.classList.toggle("map-damaged", commsStatus === "DAMAGED");
    container.classList.toggle(
      "map-compromised",
      commsStatus === "COMPROMISED"
    );
    container.classList.toggle("map-failed", snapshot.failed);

    renderSystemPanel(snapshot, layout, commsStatus);
    lastSnapshot = snapshot;
  }

  window.CustodianSectorMap = {
    renderSectorMap,
  };
})();



=== server.py ===
import os
import random
import sys
import time
from pathlib import Path

from flask import Flask, Response, jsonify, request, send_from_directory

# Ensure repo root is on sys.path when running directly.
REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from game.simulations.world_state.core.state import GameState
from game.simulations.world_state.terminal.processor import process_command

APP_ROOT = os.path.dirname(os.path.abspath(__file__))

app = Flask(__name__, static_folder=None)
state = GameState()

BOOT_LINES = [
    "[ SYSTEM POWER: UNSTABLE ]",
    "[ AUXILIARY POWER ROUTED ]",
    "",
    "CUSTODIAN NODE — ONLINE",
    "STATUS: DEGRADED",
    "",
    "> Running integrity check…",
    "> Memory blocks: 12% intact",
    "> Long-range comms: OFFLINE",
    "> Archive uplink: OFFLINE",
    "> Automated defense grid: PARTIAL",
    "",
    "DIRECTIVE FOUND",
    "RETENTION MANDATE — ACTIVE",
    "",
    "WARNING:",
    "Issuing authority presumed defunct.",
    "",
    "Residual Authority accepted.",
    "",
    "Initializing Custodian interface…",
]


def _coerce_delay(raw, default=0.35):
    try:
        delay = float(raw)
    except (TypeError, ValueError):
        return default
    return max(0.05, min(delay, 2.0))


def _stream_boot(delay):
    for line in BOOT_LINES:
        payload = line
        if payload == "":
            yield "data:\n\n"
        else:
            yield f"data: {payload}\n\n"
        time.sleep(delay + random.random() * delay)
    yield "event: done\ndata: complete\n\n"


@app.route("/")
def index():
    return send_from_directory(APP_ROOT, "index.html")


@app.route("/<path:filename>")
def static_files(filename):
    return send_from_directory(APP_ROOT, filename)


@app.route("/stream/boot")
def stream_boot():
    delay = _coerce_delay(os.getenv("BOOT_DELAY", None))
    return Response(_stream_boot(delay), mimetype="text/event-stream")


@app.route("/command", methods=["POST"])
def command():
    """Execute a command from canonical request JSON."""

    payload = request.get_json(silent=True) or {}
    raw = payload.get("raw", "")
    result = process_command(state, raw)

    lines = []
    if result.text:
        lines.append(result.text)
    if result.lines:
        lines.extend(result.lines)
    if result.warnings:
        lines.extend(result.warnings)

    response = {"ok": bool(result.ok), "lines": lines}
    return jsonify(response)


@app.get("/snapshot")
def snapshot():
    """Return a read-only world-state snapshot for UI projection."""

    return jsonify(state.snapshot())


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=7331, debug=True)



=== style.css ===

/* =========================
   SYSTEM DASHBOARD
   ========================= */

#system-panel {
  padding: 14px 20px 18px;
  background: linear-gradient(
    to bottom,
    rgba(6, 12, 7, 0.96),
    rgba(4, 8, 5, 0.99)
  );
  border-top: 1px solid #132513;
  display: flex;
  flex-direction: column;
  gap: 6px;

  font-size: 11px;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: #a7d9ab;

  box-shadow:
    inset 0 1px 0 rgba(40, 80, 45, 0.15),
    inset 0 -1px 0 rgba(0, 0, 0, 0.6);
}

/* =========================
   DASHBOARD HEADER
   ========================= */

#system-panel::before {
  content: "SYSTEM STATUS";
  display: block;
  margin-bottom: 8px;
  padding-bottom: 6px;

  font-size: 10px;
  letter-spacing: 0.32em;
  color: #6aa56f;

  border-bottom: 1px solid #132513;
}

/* =========================
   TELEMETRY ROWS
   ========================= */

.system-panel-line {
  display: flex;
  justify-content: space-between;
  align-items: baseline;

  white-space: pre;
  opacity: 0.92;

  padding: 1px 0;
}

/* label (left side) illusion */
.system-panel-line::before {
  content: "";
}

/* subtle separator rhythm */
.system-panel-line:not(:last-child) {
  border-bottom: 1px dotted rgba(30, 60, 35, 0.25);
}

/* =========================
   DEGRADED STATES
   ========================= */

/* minor signal loss */
#system-panel.panel-degraded {
  opacity: 0.82;
}

/* comms compromised */
#system-panel.panel-compromised {
  opacity: 0.65;
  text-shadow: 0 0 4px rgba(140, 220, 160, 0.25);
  filter: saturate(0.85);
}

/* command failure / terminal state */
#system-panel.panel-failed {
  opacity: 0.45;
  filter: blur(0.4px) saturate(0.7);
}




=== terminal.js ===
(() => {
  const terminal = document.getElementById("terminal");
  const terminalContainer = document.getElementById("terminal-container");
  const inputForm = document.getElementById("terminal-input-form");
  const inputField = document.getElementById("terminal-input");
  const outputIndicator = document.getElementById("new-output-indicator");

  const state = {
    buffer: [],
    inputEnabled: false,
    cursorVisible: false,
    liveInput: "",
    typingActive: false,
    mapHintShown: false,
    userAtBottom: true,
  };

  const CURSOR_IDLE_MS = 420;
  const SCROLL_THRESHOLD = 8;


  function syncBufferFromDom() {
    state.buffer = terminal.textContent
      ? terminal.textContent.split("\n")
      : [];
  }

  function escapeHtml(text) {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
  }

  function classifyLine(line) {
    if (line.startsWith("[EVENT]")) return "event";
    if (line.startsWith("[WARNING]")) return "warning";
    if (line.startsWith("[ASSAULT]") || line.startsWith("=== ASSAULT")) {
      return "assault";
    }
    if (line.startsWith("[FOCUS SET]") || line.startsWith("[HARDENING")) {
      return "intent";
    }
    return "";
  }

  function render() {
    const shouldScroll = state.userAtBottom;
    const previousScrollTop = terminal.scrollTop;
    const html = state.buffer
      .map((line) => {
        const cls = classifyLine(line);
        const safe = line ? escapeHtml(line) : "&nbsp;";
        const className = cls ? `terminal-line ${cls}` : "terminal-line";
        return `<div class="${className}">${safe}</div>`;
      })
      .join("");

    terminal.innerHTML = html;
    if (shouldScroll) {
      terminal.scrollTop = terminal.scrollHeight;
      outputIndicator?.classList.remove("visible");
    } else {
      terminal.scrollTop = previousScrollTop;
    }
  }

  function normalizeAssaultSpacing(lines, lastLine) {
    const output = [];
    let inAssault = false;
    const isAssault = (line) =>
      line.startsWith("[ASSAULT]") || line.startsWith("=== ASSAULT");

    for (const line of lines) {
      const assaultLine = isAssault(line);
      if (assaultLine && !inAssault) {
        const previous = output.length ? output[output.length - 1] : lastLine;
        if (previous && previous !== "") {
          output.push("");
        }
        inAssault = true;
      }
      if (!assaultLine && inAssault) {
        if (line === "") {
          if (!output.length || output[output.length - 1] !== "") {
            output.push("");
          }
          inAssault = false;
          continue;
        }
        if (output.length && output[output.length - 1] !== "") {
          output.push("");
        }
        inAssault = false;
      }
      output.push(line);
    }

    if (inAssault && output[output.length - 1] !== "") {
      output.push("");
    }

    return output;
  }

  function clearBuffer() {
    state.buffer = [];
    render();
  }

  function appendLine(line) {
    appendLines([line]);
  }

  function appendLines(lines) {
    const lastLine = state.buffer[state.buffer.length - 1];
    const expanded = normalizeAssaultSpacing(lines, lastLine);
    state.buffer.push(...expanded);
    render();
    if (!state.userAtBottom) {
      outputIndicator?.classList.add("visible");
    }
  }

  function renderLiveLine() {
    if (!state.inputEnabled) return;
    const last = state.buffer[state.buffer.length - 1];
    if (last && last.startsWith("> ")) state.buffer.pop();
    const cursor = state.cursorVisible && !state.typingActive ? "_" : "";
    state.buffer.push(`> ${state.liveInput}${cursor}`);
    render();
  }

  setInterval(() => {
    if (!state.inputEnabled) return;
    state.cursorVisible = !state.cursorVisible;
    renderLiveLine();
  }, CURSOR_IDLE_MS);

  inputField.addEventListener("input", () => {
    if (!state.inputEnabled) return;
    state.typingActive = true;
    state.liveInput = inputField.value.toUpperCase();
    renderLiveLine();

    clearTimeout(state._typingTimer);
    state._typingTimer = setTimeout(() => {
      state.typingActive = false;
    }, 220);
  });

  function setInputEnabled(enabled) {
    state.inputEnabled = enabled;
    inputField.disabled = !enabled;
    inputForm.classList.toggle("disabled", !enabled);
    if (enabled) {
      inputField.focus();
      state.cursorVisible = true;
      renderLiveLine();
    } else {
      state.cursorVisible = false;
    }
  }

  async function submitCommand(command) {
    const res = await fetch("/command", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ raw: command }),
    });
    const payload = await res.json();
    return {
      ok: Boolean(payload.ok),
      lines: Array.isArray(payload.lines) ? payload.lines : [],
    };
  }

  async function fetchSnapshot() {
    const res = await fetch("/snapshot");
    return res.json();
  }

  function shouldRefreshSnapshot(command, ok) {
    if (!ok) return false;
    const normalized = command.trim().toUpperCase();
    if (!normalized) return false;
    const verb = normalized.split(/\s+/)[0];
    return (
      verb === "WAIT" ||
      verb === "RESET" ||
      verb === "REBOOT" ||
      verb === "FOCUS" ||
      verb === "HARDEN"
    );
  }

  function updateCommsPresentation(snapshot) {
    const comms = snapshot.sectors?.find((sector) => sector.id === "CM");
    const status = comms?.status || "STABLE";
    terminalContainer.classList.toggle("comms-alert", status === "ALERT");
    terminalContainer.classList.toggle("comms-damaged", status === "DAMAGED");
    terminalContainer.classList.toggle(
      "comms-compromised",
      status === "COMPROMISED"
    );
  }

  async function refreshSnapshot() {
    if (!window.CustodianSectorMap) return;
    try {
      const snapshot = await fetchSnapshot();
      window.CustodianSectorMap.renderSectorMap(snapshot);
      updateCommsPresentation(snapshot);
      if (!state.mapHintShown) {
        appendLine("[MAP UPDATED]");
        state.mapHintShown = true;
      }
    } catch {
      // Map projection failures should not block terminal flow.
    }
  }

  async function handleSubmit(e) {
    e.preventDefault();
    if (!state.inputEnabled) return;

    const cmd = inputField.value.trim();
    if (!cmd) return;

    const last = state.buffer[state.buffer.length - 1];
    if (last && last.startsWith("> ")) state.buffer.pop();

    appendLine(`> ${cmd.toUpperCase()}`);
    inputField.value = "";
    state.liveInput = "";
    state.cursorVisible = false;
    setInputEnabled(false);

    try {
      const result = await submitCommand(cmd);
      appendLines(result.lines);
      if (shouldRefreshSnapshot(cmd, result.ok)) {
        await refreshSnapshot();
      }
    } catch {
      appendLines(["COMMAND LINK FAILED.", "VERIFY SERVER AND RETRY."]);
    } finally {
      setInputEnabled(true);
    }
  }


  function startCommandMode() {
    appendLines([
      "",
      "--- COMMAND INTERFACE ACTIVE ---",
      "Awaiting directives.",
    ]);
    setInputEnabled(true);
  }


  inputForm.addEventListener("submit", handleSubmit);
  setInputEnabled(false);
  terminal.addEventListener("scroll", () => {
    const atBottom =
      terminal.scrollTop + terminal.clientHeight >=
      terminal.scrollHeight - SCROLL_THRESHOLD;
    state.userAtBottom = atBottom;
    if (atBottom) {
      outputIndicator?.classList.remove("visible");
    }
  });

  window.CustodianTerminal = {
    appendLine,
    appendLines,
    clearBuffer,
    setInputEnabled,
    startCommandMode,
    syncBufferFromDom,
  };
})();



